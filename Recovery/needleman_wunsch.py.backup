import numpy as np
matchScore = 5
mismatchScore = -3
gapScore = -4
d = gapScore

def create_matriz(rows, cols):
    return [[0]*cols for i in range(rows)]

def S(ai, bi):
    return matchScore if ai == bi else mismatchScore

def set_scores(match, mismatch, indel):
    matchScore, mismatchScore, gapScore = match, mismatch, indel

def init_DP(F, rows, cols):
    for i in range(rows):
        F[i][0] = d*i
    for j in range(cols):
        F[0][j] = d*j

def compute_DP(F, A, B):
    for i in range(1,len(A)+1):
        for j in range(1,len(B)+1):
            match = F[i-1][j-1] + S(A[i-1],B[j-1])
            delete = F[i-1][j] + d
            insert = F[i][j-1] + d
            F[i][j] = max(match, insert, delete)

def stackback(F, A, B):
    AlignmentA, AlignmentB = '', ''
    i, j = len(A), len(B)
    while (i >= 0 and j >= 0):
        if i == 0 and j == 0:
            break
        if (F[i][j] == F[i-1][j-1] + S(A[i-1], B[j-1])):
            AlignmentA = A[i-1] + AlignmentA
            AlignmentB = B[j-1] + AlignmentB
            i = i - 1
            j = j - 1
        elif (F[i][j] == F[i-1][j] + d):
            AlignmentA = A[i-1] + AlignmentA
            AlignmentB = "-" + AlignmentB
            i = i - 1
        else:
            AlignmentA = "-" + AlignmentA
            AlignmentB = B[j-1] + AlignmentB
            j = j - 1

    return  AlignmentA, AlignmentB

def compute_identity(seq1, seq2):
    matches = 0
    separator = ''
    for index in range(len(seq1)):
        if seq1[index] == seq2[index]:
            matches += 1
            separator += '|'
        else:
            separator += ' '
    identity = (float(matches)/float(len(seq1)))*100.0
    return separator, identity

def needleman_wunsch(A,B,match,mismatch,indel):
    set_scores(int(match),int(mismatch),int(indel))
    #print(match,mismatch,indel)
    rows = len(A)+1
    cols = len(B)+1
    F = create_matriz(rows, cols)
    init_DP(F, rows, cols)
    compute_DP(F, A, B)
    AlignmentA, AlignmentB = stackback(F, A, B)
    sep, identity = compute_identity(AlignmentA, AlignmentB)
    return sep, AlignmentA, AlignmentB, F, identity

#sep, AlignmentA, AlignmentB, F, score = needleman_wunsch('ACGCGGC','GCCGCGAG', 2,-30,-50)
sep, AlignmentA, AlignmentB, F, score =needleman_wunsch('MACWPQLRLLLWKNLTFRRRQTCQLLLEVAWPLFIFLILISVRL ','MACWSQLRLLLWKNLTFRRRQTCQLLLEVAWPLFIFLILISVRL', 1,-1,-3)
print(score)


'''
print(len('ATGTTGCATGCAGGTCCGTACTGACTG'))
print(AlignmentB)
print(sep)
print( AlignmentA)
print(score)
'''

'''

NONE, LEFT, UP, DIAG = 0, 1, 2, 3


def needle_wunsch(sequence_a, sequence_b, scorer, gap_penalty=1, scale=1.0):
    """
    :param sequence_a: any iterable with a fixed order.
    :param sequence_b: any iterable with a fixed order.
    :param scorer: a dictionary holding the scores between all pairwise
                   items in sequence_a and sequence_b.
    :param gap_penalty: the gap opening penalty used in the analysis.
    :param scale: the factor by which gap_penalty should be decreased.
    :return: numpy matrix, backtrace pointers and the distance between the
             two sequences.
    """
    len1, len2 = len(sequence_a), len(sequence_b)
    pointer = np.zeros((len1 + 1, len2 + 1), dtype='i')
    matrix = np.zeros((len1 + 1, len2 + 1), dtype='f')
    length = np.zeros((len1 + 1, len2 + 1), dtype='f')
    pointer[0, 0] = NONE
    pointer[0, 1:] = LEFT
    pointer[1:, 0] = UP
    for i in range(1, len1 + 1):
        matrix[i, 0] = matrix[i - 1, 0] + gap_penalty * scale
        length[i, 0] = length[i - 1, 0] + gap_penalty * scale
    for j in range(1, len2 + 1):
        matrix[0, j] = matrix[0, j - 1] + gap_penalty * scale
        length[0, j] = length[0, j - 1] + gap_penalty * scale
    for i in range(1, len1 + 1):
        for j in range(1, len2 + 1):
            gap_a = matrix[i - 1, j] + (gap_penalty * scale if pointer[i - 1, j] == UP else gap_penalty)
            gap_b = matrix[i, j - 1] + (gap_penalty * scale if pointer[i, j - 1] == LEFT else gap_penalty)
            match = matrix[i - 1, j - 1] + scorer[i - 1, j - 1]
            if gap_a < match and gap_a <= gap_b:
                matrix[i, j] = gap_a
                pointer[i, j] = UP
            elif match <= gap_b:
                matrix[i, j] = match
                pointer[i, j] = DIAG
            else:
                matrix[i, j] = gap_b
                pointer[i, j] = LEFT
            p = pointer[i, j]
            l_gap_a = length[i - 1, j] + (gap_penalty * scale if p == UP else 0)
            l_gap_b = length[i, j - 1] + (gap_penalty * scale if p == LEFT else 0)
            l_match = length[i - 1, j - 1] + (scorer[i - 1, j - 1] if p == DIAG else 0)
            length[i, j] = max(l_gap_a, l_gap_b, l_match)
    # normalize the distance
    distance = matrix[len1, len2] / length[len1, len2]
    return matrix, pointer, distance


def backtrace(pointer, sequence_a, sequence_b):
    i, j = len(sequence_a), len(sequence_b)
    align1, align2 = [], []
    fill_a, fill_b = '_', '_'
    if any(isinstance(e, (tuple, list)) for e in sequence_a):
        fill_a = ('_',) * len(sequence_a[0])
    if any(isinstance(e, (tuple, list)) for e in sequence_b):
        fill_b = ('_',) * len(sequence_b[0])
    while True:
        p = pointer[i, j]
        if p == NONE:
            break
        if p == DIAG:
            align1.append(sequence_a[i - 1])
            align2.append(sequence_b[j - 1])
            i, j = i - 1, j - 1
        elif p == LEFT:
            align1.append(fill_a)
            align2.append(sequence_b[j - 1])
            j -= 1
        elif p == UP:
            align1.append(sequence_a[i - 1])
            align2.append(fill_b)
            i -= 1
        else:
            raise ValueError("Something went terribly wrong.")
    return align1[::-1], align2[::-1]


def align(sequence_a, sequence_b, scores, gap_penalty=1, scale=1.0):
    matrix, pointer, distance = needle_wunsch(
        sequence_a, sequence_b, scores, gap_penalty, scale)
    align1, align2 = backtrace(pointer, sequence_a, sequence_b)
    return align1, align2, distance
scores=1

def pairwise_distances(sequences, fn):
    distances = np.zeros((len(sequences), len(sequences)))
    for i in range(len(sequences)):
        for j in range(i):
            _, _, distance = fn(sequences[i], sequences[j])
            distances[i, j] = distance
            distances[j, i] = distances[i, j]
    return distances

scorer=[1,-1]

a=needle_wunsch('MACWPQLRLLLWKNLTFRRRQTCQLLLEVAWPLFIFLILISVRL', 'MACWPQLRLLLWKNLTFRRRQTCQLLLEVAWPLFIFLILISVRL',scorer, gap_penalty=1, scale=1.0)
'''

---------------------------------------------------------------

from globalalignmentend got


def globAlignment(Que,Data,Indel,MM,M):
    len_Que = len(Que); len_Data = len(Data)
    #null_matrix = generate_matrix([len_Que, len_Data])

    ## Orthogonel Adjustment
    zero_list=[]
    a=np.arange(0,(-Indel*len_Que)-Indel,-Indel)
    #np.asarray(a)
    zero_list.append(a)
    for i in range(-Indel,(-Indel*len_Data)-Indel,-Indel):
        p=np.zeros([len_Que+1])
        p[0]=i
        zero_list.append(p)
    null_matrix=np.asmatrix(zero_list)

    ## Manipulate Ic kısım
    for iterator_i in range(len_Data+1):
        for iterator_j in range(len_Que+1):
            if iterator_i !=0 and iterator_j !=0:
                el1=Que[iterator_j-1]; el2=Data[iterator_i-1]
                if el1 == el2:
                    list_will_choose = [(null_matrix[iterator_i-1,iterator_j-1]) + M,
                                        (null_matrix[iterator_i,iterator_j-1]) - Indel,
                                        (null_matrix[iterator_i-1,iterator_j]) - Indel]
                    choose_max = max(list_will_choose)
                    null_matrix[iterator_i,iterator_j] = choose_max
                else:
                    list_will_choose = [(null_matrix[iterator_i - 1,iterator_j - 1]) - MM,
                                        (null_matrix[iterator_i,iterator_j - 1]) - Indel,
                                        (null_matrix[iterator_i - 1,iterator_j]) - Indel]
                    choose_max = max(list_will_choose)
                    null_matrix[iterator_i,iterator_j] = choose_max
    ed=np.zeros([len_Data+1,len_Que+1])

    for i in range(len(Que)+1):
        for j in range(len(Data)+1):
            ed[j][i]=null_matrix[j,i]
    print(ed)
    return ed #export without non-matrix from numpy
